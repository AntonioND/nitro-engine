// SPDX-License-Identifier: CC0-1.0
//
// SPDX-FileContributor: Antonio Niño Díaz, 2008-2011, 2019, 2022
//
// This file is part of Nitro Engine

#include <NEMain.h>

// Files autogenerated from bin files inside of the folder data
#include "teapot_bin.h"
#include "teapot_tex_bin.h"

NE_Camera *Camera;
NE_Model *ModelSpecular, *ModelDiffuse;
NE_Material *MaterialSpecular, *MaterialDiffuse;

bool wireframe;

void Draw3DScene1(void)
{
    NE_CameraUse(Camera);

    NE_PolyFormat(wireframe ? 0 : 31, 0, NE_LIGHT_ALL, NE_CULL_BACK, 0);

    NE_ModelDraw(ModelSpecular);

    printf("\x1b[22;0H"
           "Polygon count: %d   \n"
           "Vertex count: %d   ",
           NE_GetPolygonCount(),
           NE_GetVertexCount());
}

void Draw3DScene2(void)
{
    NE_CameraUse(Camera);

    NE_PolyFormat(wireframe ? 0 : 31, 0, NE_LIGHT_ALL, NE_CULL_BACK, 0);

    NE_ModelDraw(ModelDiffuse);
}

int main(void)
{
    irqEnable(IRQ_HBLANK);
    irqSet(IRQ_VBLANK, NE_VBLFunc);
    irqSet(IRQ_HBLANK, NE_HBLFunc);

    NE_InitDual3D();
    NE_InitConsole();

    // Allocate objects
    Camera = NE_CameraCreate();
    ModelSpecular = NE_ModelCreate(NE_Static);
    ModelDiffuse = NE_ModelCreate(NE_Static);
    MaterialSpecular = NE_MaterialCreate();
    MaterialDiffuse = NE_MaterialCreate();

    // Setup camera
    NE_CameraSet(Camera,
                 0, 0, 3,
                 0, 0, 0,
                 0, 1, 0);

    // Load model
    NE_ModelLoadStaticMesh(ModelSpecular, (u32*)teapot_bin);
    NE_ModelClone(ModelDiffuse, ModelSpecular);

    // Load texture and clone it. The texture coordinates of the model are
    // outside of [0.0, 1.0], so it is needed to enable wrapping.
    NE_MaterialTexLoad(MaterialSpecular, NE_A1RGB5, 256, 256,
                       NE_TEXGEN_TEXCOORD | NE_TEXTURE_WRAP_S | NE_TEXTURE_WRAP_T,
                       (u8 *)teapot_tex_bin);
    NE_MaterialClone(MaterialSpecular, MaterialDiffuse);

    NE_ModelSetMaterial(ModelSpecular, MaterialSpecular);
    NE_ModelSetMaterial(ModelDiffuse, MaterialDiffuse);

    // Set some propierties to the materials

    NE_MaterialSetPropierties(MaterialSpecular,
                              RGB15(0, 0, 0),    // Diffuse
                              RGB15(0, 0, 0),    // Ambient
                              RGB15(31, 31, 31), // Specular
                              RGB15(0, 0, 0),    // Emission
                              false, true);      // Vtx color, use shininess table

    NE_MaterialSetPropierties(MaterialDiffuse,
                              RGB15(31, 31, 31), // Diffuse
                              RGB15(0, 0, 0),    // Ambient
                              RGB15(0, 0, 0),    // Specular
                              RGB15(0, 0, 0),    // Emission
                              false, false);     // Vtx color, use shininess table

    // Set light color and direction
    NE_LightSet(0, NE_White, 0, 1, 0);
    NE_LightSet(1, NE_Blue, 0, -1, 0);
    NE_LightSet(2, NE_Red, 1, 0, 0);
    NE_LightSet(3, NE_Green, -1, 0, 0);

    NE_ShininessFunction shininess = NE_SHININESS_CUBIC;

    while (1)
    {
        NE_WaitForVBL(0);

        // Get keys information
        scanKeys();
        uint32 keys = keysHeld();
        uint32 keys_down = keysDown();

        printf("\x1b[0;0H"
               "PAD: Rotate\n"
               "A: Set wireframe mode\n"
               "L/R: Change shininess\n");

        if (keys & KEY_A)
            wireframe = true;
        else
            wireframe = false;

        // Rotate model
        if (keys & KEY_UP)
        {
            NE_ModelRotate(ModelSpecular, -2, 0, 0);
            NE_ModelRotate(ModelDiffuse, -2, 0, 0);
        }
        if (keys & KEY_DOWN)
        {
            NE_ModelRotate(ModelSpecular, 2, 0, 0);
            NE_ModelRotate(ModelDiffuse, 2, 0, 0);
        }
        if (keys & KEY_RIGHT)
        {
            NE_ModelRotate(ModelSpecular, 0, 2, 0);
            NE_ModelRotate(ModelDiffuse, 0, 2, 0);
        }
        if (keys & KEY_LEFT)
        {
            NE_ModelRotate(ModelSpecular, 0, -2, 0);
            NE_ModelRotate(ModelDiffuse, 0, -2, 0);
        }

        // Shininess table
        // ---------------

        const char *names[] = {
            [NE_SHININESS_NONE]      = "None     ",
            [NE_SHININESS_LINEAR]    = "Linear   ",
            [NE_SHININESS_QUADRATIC] = "Quadratic",
            [NE_SHININESS_CUBIC]     = "Cubic    ",
            [NE_SHININESS_QUARTIC]   = "Quartic  "
        };
        printf("\nShininess: %s", names[shininess]);

        if (keys_down & KEY_L)
        {
            if (shininess > NE_SHININESS_LINEAR)
                shininess--;
        }
        if (keys_down & KEY_R)
        {
            if (shininess < NE_SHININESS_QUARTIC)
                shininess++;
        }

        NE_ShininessTableGenerate(shininess);

        NE_ProcessDual(Draw3DScene1, Draw3DScene2);
    }

    return 0;
}
